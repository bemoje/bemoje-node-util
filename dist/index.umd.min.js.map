{"version":3,"file":"index.umd.min.js","sources":["../src/libs/array/src/arr2dToCSV.ts","../src/libs/array/src/arrAssignFrom.ts","../src/libs/array/src/arrEvery.ts","../src/libs/array/src/arrFlatten.ts","../src/libs/array/src/arrMapMutable.ts","../src/libs/array/src/arrShallowEquals.ts","../src/libs/array/src/arrSwap.ts","../src/libs/sort.ts","../src/libs/datastructures/src/Matrix.ts","../src/libs/validation.ts","../src/libs/object.ts","../src/libs/Base.ts","../src/libs/regex.ts","../src/libs/spreadsheet/src/letterToCol.ts","../src/libs/spreadsheet/src/A1ToColRow.ts","../src/libs/spreadsheet/src/colToLetter.ts","../src/libs/datastructures/src/Table.ts","../src/libs/number.ts","../src/libs/string.ts","../src/libs/node.ts","../src/libs/function/src/ExtensibleFunction.ts","../src/libs/datastructures/src/SortedArray.ts","../src/libs/time.ts","../src/libs/array/src/arrFilterMutable.ts","../src/libs/array/src/arrFlattenMutable.ts","../src/libs/array/src/arrIndicesOf.ts","../src/libs/array/src/arrShuffle.ts","../src/libs/array/src/arrSome.ts","../src/libs/array/src/arrSortNumeric.ts","../src/libs/spreadsheet/src/colRowToA1.ts","../src/libs/html/src/htmlTableTo2dArray.ts","../src/libs/set.ts"],"sourcesContent":["/**\n * Converts a 2-dimensional array into a CSV string.\n * @param input a 2-dimensional array\n * @param delimiter csv delimiter\n */\nexport function arr2dToCSV<T>(input: Array<Array<T>>, delimiter = ';'): string {\n  return input.map((row) => row.join(delimiter)).join('\\n');\n}\n","/**\n * Mutably assigns the values of source array to target array. Lengths will also be identical.\n */\nexport function arrAssignFrom<T>(target: Array<T>, source: Array<T>): Array<T> {\n  target.splice(source.length);\n  for (let i = 0; i < source.length; i++) {\n    target[i] = source[i];\n  }\n  return target;\n}\n","import { Predicate } from '../../array';\n\n/**\n * Returns true if the predicate is satisfied for every element of the passed array; otherwise false.\n * @param input - The array\n * @param  predicate - A predicate callback function\n */\n\nexport function arrEvery<T>(input: Array<T>, predicate: Predicate): boolean {\n  for (let i = 0, len = input.length; i < len; i++) {\n    if (predicate(input[i], i, input) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n","/**\n * Flattens the passed array recursively to a specified depth. Immutable.\n * @param input - the array to flatten\n * @param maxDepth - the maximum recursive flattening depth.\n */\nexport function arrFlatten<T>(\n  input: Array<any>,\n  maxDepth = Number.MAX_SAFE_INTEGER,\n): Array<T> {\n  const accum = [];\n  (function recurse(arr = input, depth = 0) {\n    for (let i = 0; i < arr.length; i++) {\n      if (Array.isArray(arr[i]) && depth < maxDepth) {\n        recurse(arr[i], depth + 1);\n      } else {\n        accum.push(arr[i]);\n      }\n    }\n  })();\n  return accum;\n}\n","import { Callback } from '../../array';\n\n/**\n * Same as Array.prototype.map but performs operations in palce (not immutable).\n * @param input - input array\n * @param f - iterator\n * @example\n * ```js\n * expect(\n *   util.arrMapMutable([1, 2, 3, 4, 5], (value: number) => {\n *     return value + 1;\n *   }),\n * ).toStrictEqual([2, 3, 4, 5, 6]);\n * ```\n */\n\nexport function arrMapMutable(input: Array<any>, f: Callback): Array<any> {\n  for (let i = 0; i < input.length; i++) {\n    input[i] = f(input[i], i, input);\n  }\n  return input;\n}\n","import { arrEvery } from './arrEvery';\n\n/**\n * Returns whether or not two arrays shallow equal each other.\n * @param input1 first array\n * @param input2 second array\n */\nexport function arrShallowEquals<T>(\n  input1: Array<T>,\n  input2: Array<T>,\n): boolean {\n  if (input1.length !== input2.length) return false;\n  return arrEvery(input1, (value, i) => value === input2[i]);\n}\n","/**\n * Swap array elements in place. Runtime: O(1)\n * @param input to be modified\n * @param from index of the first element\n * @param to index of the second element\n */\nexport function arrSwap<T>(\n  input: Array<T>,\n  from: number,\n  to: number,\n): Array<T> {\n  [input[from], input[to]] = [input[to], input[from]];\n  return input;\n}\n","export type Comparator = (a: any, b: any) => number;\r\n\r\n/**\r\n * Returns a given comparator as an array compatible comparator. Behaves as if the array to sort was recursively flattened.\r\n * @param comparator compare function\r\n * @param descending whether the input comparator sorts in descending order\r\n */\r\nexport function compareArray(\r\n  comparator: Comparator,\r\n  descending = false,\r\n): Comparator {\r\n  const orderMultiplier = descending ? -1 : 1;\r\n  function recursiveCompare(\r\n    a: any,\r\n    b: any,\r\n    _lenCompareParent?: number,\r\n  ): number {\r\n    const aIsArr = Array.isArray(a);\r\n    const bIsArr = Array.isArray(b);\r\n    if (aIsArr) {\r\n      if (bIsArr) {\r\n        const aLen = a.length;\r\n        const bLen = b.length;\r\n        let lenShortest, lenCompare;\r\n        if (aLen > bLen) {\r\n          lenShortest = aLen;\r\n          lenCompare = 1 * orderMultiplier;\r\n        } else if (aLen < bLen) {\r\n          lenShortest = bLen;\r\n          lenCompare = -1 * orderMultiplier;\r\n        } else {\r\n          lenShortest = aLen;\r\n          lenCompare = 0;\r\n        }\r\n        for (let i = 0, len = lenShortest; i < len; i++) {\r\n          const res = recursiveCompare(a[i], b[i], lenCompare);\r\n          if (res !== 0) {\r\n            return res;\r\n          }\r\n        }\r\n      } else {\r\n        return 1 * orderMultiplier;\r\n      }\r\n    } else {\r\n      if (bIsArr) {\r\n        return -1 * orderMultiplier;\r\n      } else {\r\n        const res = comparator(a, b);\r\n        if (res === 0) {\r\n          return _lenCompareParent || res;\r\n        } else {\r\n          return res;\r\n        }\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n  return (a: any, b: any): number => {\r\n    return recursiveCompare(a, b);\r\n  };\r\n}\r\n\r\n/**\r\n * Number comparator function (ascending)\r\n * @param a first value to compare\r\n * @param b second value to compare\r\n */\r\nexport function compareNumber(a: number, b: number): number {\r\n  return a - b;\r\n}\r\n\r\n/**\r\n * Number comparator function (descending)\r\n * @param a first value to compare\r\n * @param b second value to compare\r\n */\r\nexport function compareNumberDescending(a: number, b: number): number {\r\n  return b - a;\r\n}\r\n\r\n/**\r\n * number, bigint, boolean comparator function (ascending)\r\n * @param a first value to compare\r\n * @param b second value to compare\r\n */\r\nexport function compareNumeric(\r\n  a: number | bigint | boolean,\r\n  b: number | bigint | boolean,\r\n): number {\r\n  if (a < b) return -1;\r\n  if (a > b) return 1;\r\n  return 0;\r\n}\r\n\r\n/**\r\n * number, bigint, boolean comparator function (descending)\r\n * @param a first value to compare\r\n * @param b second value to compare\r\n */\r\nexport function compareNumericDescending(\r\n  a: number | bigint | boolean,\r\n  b: number | bigint | boolean,\r\n): number {\r\n  if (a > b) return -1;\r\n  if (a < b) return 1;\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Alpha numeric comparator function (ascending)\r\n * @param a first value to compare\r\n * @param b second value to compare\r\n */\r\nexport function compareString(a: string, b: string): number {\r\n  return a.localeCompare(b);\r\n}\r\n\r\n/**\r\n * Alpha numeric comparator function (descending)\r\n * @param a first value to compare\r\n * @param b second value to compare\r\n */\r\nexport function compareStringDescending(a: string, b: string): number {\r\n  return b.localeCompare(a);\r\n}\r\n","export class Matrix {\r\n  protected matrix: Array<Array<number>>;\r\n  protected immutable = false;\r\n\r\n  public static fromArray(array: Array<Array<number>>): Matrix {\r\n    const cols = array[0].length;\r\n    const m = new this(array.length, cols);\r\n    for (let r = 0; r < array.length; r++) {\r\n      if (array[r].length !== cols) {\r\n        throw new Error('All rows must have the same length.');\r\n      }\r\n      for (let c = 0; c < cols; c++) {\r\n        m.matrix[r][c] = array[r][c];\r\n      }\r\n    }\r\n    return m;\r\n  }\r\n\r\n  public static fromIterable(iterable: Iterable<Iterable<number>>): Matrix {\r\n    const arr = [];\r\n    for (const row of iterable) {\r\n      arr.push([...row]);\r\n    }\r\n    return this.fromArray(arr);\r\n  }\r\n\r\n  public static identity(size: number): Matrix {\r\n    const m = new Matrix(size, size);\r\n    for (let i = 0; i < size; i++) {\r\n      m.matrix[i][i] = 1;\r\n    }\r\n    return m;\r\n  }\r\n\r\n  constructor(rows: number, cols: number) {\r\n    if (rows < 1) throw new Error('Expected rows to be greater than zero.');\r\n    if (cols < 1) throw new Error('Expected cols to be greater than zero.');\r\n    this.matrix = new Array(rows);\r\n    for (let r = 0; r < rows; r++) {\r\n      this.matrix[r] = new Array(cols).fill(0);\r\n    }\r\n  }\r\n\r\n  public get rows(): number {\r\n    return this.matrix.length;\r\n  }\r\n\r\n  public get cols(): number {\r\n    return this.matrix[0].length;\r\n  }\r\n\r\n  public isSameInstanceAs(other: Matrix): boolean {\r\n    return this === other;\r\n  }\r\n\r\n  public getImmutable(): boolean {\r\n    return this.immutable;\r\n  }\r\n\r\n  public setImmutable(immutable: boolean): Matrix {\r\n    this.immutable = immutable;\r\n    return this;\r\n  }\r\n\r\n  public deepEquals(other: Matrix | Array<Array<number>>): boolean {\r\n    const m = other instanceof Matrix ? other.matrix : other;\r\n    for (let r = 0; r < this.rows; r++) {\r\n      for (let c = 0; c < this.cols; c++) {\r\n        if (this.matrix[r][c] !== m[r][c]) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public set(row: number, col: number, value: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    m.matrix[row][col] = value;\r\n    return m;\r\n  }\r\n\r\n  public get(row: number, col: number): number {\r\n    return this.matrix[row][col];\r\n  }\r\n\r\n  public has(row: number, col: number): boolean {\r\n    return row < this.rows && col < this.cols && row >= 0 && col >= 0;\r\n  }\r\n\r\n  public toArray(): Array<Array<number>> {\r\n    const result = new Array(this.rows);\r\n    for (let r = 0; r < this.rows; r++) {\r\n      result[r] = this.matrix[r].slice();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public clone(): Matrix {\r\n    const clone = new Matrix(this.rows, this.cols);\r\n    for (let r = 0; r < this.rows; r++) {\r\n      for (let c = 0; c < this.cols; c++) {\r\n        clone.matrix[r][c] = this.matrix[r][c];\r\n      }\r\n    }\r\n    return clone;\r\n  }\r\n\r\n  public forEach(f: (value: number, row: number, col: number) => void | boolean): Matrix {\r\n    for (let r = 0; r < this.rows; r++) {\r\n      for (let c = 0; c < this.cols; c++) {\r\n        if (f(this.matrix[r][c], r, c) === false) {\r\n          return this;\r\n        }\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public forEachInRow(row: number, f: (value: number, col: number) => void | boolean): Matrix {\r\n    for (let c = 0; c < this.cols; c++) {\r\n      if (f(this.matrix[row][c], c) === false) {\r\n        return this;\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public forEachInCol(col: number, f: (value: number, row: number) => void | boolean): Matrix {\r\n    for (let r = 0; r < this.rows; r++) {\r\n      if (f(this.matrix[r][col], r) === false) {\r\n        return this;\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public forEachInDiagonal(f: (value: number, row: number, col: number) => void | boolean): Matrix {\r\n    for (let i = 0; i < Math.min(this.rows, this.cols); i++) {\r\n      if (f(this.matrix[i][i], i, i) === false) {\r\n        return this;\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public map(f: (value: number, row: number, col: number) => number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    for (let r = 0; r < this.rows; r++) {\r\n      for (let c = 0; c < this.cols; c++) {\r\n        m.matrix[r][c] = f(this.matrix[r][c], r, c);\r\n      }\r\n    }\r\n    return m;\r\n  }\r\n\r\n  public *[Symbol.iterator](): Generator<number> {\r\n    for (let r = 0; r < this.rows; r++) {\r\n      for (let c = 0; c < this.cols; c++) {\r\n        yield this.matrix[r][c];\r\n      }\r\n    }\r\n  }\r\n\r\n  public *values(): Generator<number> {\r\n    yield* this;\r\n  }\r\n\r\n  public mapRow(row: number, f: (value: number, col: number) => number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    for (let c = 0; c < this.cols; c++) {\r\n      m.matrix[row][c] = f(this.matrix[row][c], c);\r\n    }\r\n    return m;\r\n  }\r\n\r\n  public mapCol(col: number, f: (value: number, row: number) => number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    for (let r = 0; r < this.rows; r++) {\r\n      m.matrix[r][col] = f(this.matrix[r][col], r);\r\n    }\r\n    return m;\r\n  }\r\n\r\n  public appendRow(row?: Array<number>): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    if (row) {\r\n      if (row.length !== this.cols) {\r\n        throw new Error('Row must have length ' + this.cols);\r\n      }\r\n    } else {\r\n      row = new Array(this.cols).fill(0);\r\n    }\r\n    m.matrix.push(row);\r\n    return m;\r\n  }\r\n\r\n  public appendCol(col?: Array<number>): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    if (col) {\r\n      if (col.length !== this.rows) {\r\n        throw new Error('Col must have length ' + this.rows);\r\n      }\r\n    } else {\r\n      col = new Array(this.rows).fill(0);\r\n    }\r\n    for (let r = 0; r < this.rows; r++) {\r\n      m.matrix[r].push(col[r]);\r\n    }\r\n    return m;\r\n  }\r\n\r\n  public addBy(n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.map((value: number) => value + n);\r\n  }\r\n\r\n  public subtractBy(n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.map((value: number) => value - n);\r\n  }\r\n\r\n  public multiplyBy(n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.map((value: number) => value * n);\r\n  }\r\n\r\n  public divideBy(n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.map((value: number) => value / n);\r\n  }\r\n\r\n  public addRowBy(row: number, n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.mapRow(row, (value: number) => value + n);\r\n  }\r\n\r\n  public subtractRowBy(row: number, n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.mapRow(row, (value: number) => value - n);\r\n  }\r\n\r\n  public multiplyRowBy(row: number, n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.mapRow(row, (value: number) => value * n);\r\n  }\r\n\r\n  public divideRowBy(row: number, n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.mapRow(row, (value: number) => value / n);\r\n  }\r\n\r\n  public addColBy(col: number, n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.mapCol(col, (value: number) => value + n);\r\n  }\r\n\r\n  public subtractColBy(col: number, n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.mapCol(col, (value: number) => value - n);\r\n  }\r\n\r\n  public multiplyColBy(col: number, n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.mapCol(col, (value: number) => value * n);\r\n  }\r\n\r\n  public divideColBy(col: number, n: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    return m.mapCol(col, (value: number) => value / n);\r\n  }\r\n\r\n  public swapRows(row1: number, row2: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    const r1 = m.matrix[row1];\r\n    const r2 = m.matrix[row2];\r\n    m.matrix[row1] = r2;\r\n    m.matrix[row2] = r1;\r\n    return m;\r\n  }\r\n\r\n  public swapCols(col1: number, col2: number): Matrix {\r\n    const m = this.immutable ? this.clone() : this;\r\n    for (let r = 0; r < this.rows; r++) {\r\n      const v1 = m.matrix[r][col1];\r\n      const v2 = m.matrix[r][col2];\r\n      m.matrix[r][col1] = v2;\r\n      m.matrix[r][col2] = v1;\r\n    }\r\n    return m;\r\n  }\r\n\r\n  public some(f: (value: number, row: number, col: number) => boolean): boolean {\r\n    for (let r = 0; r < this.rows; r++) {\r\n      for (let c = 0; c < this.cols; c++) {\r\n        if (f(this.matrix[r][c], r, c)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public every(f: (value: number, row: number, col: number) => boolean): boolean {\r\n    for (let r = 0; r < this.rows; r++) {\r\n      for (let c = 0; c < this.cols; c++) {\r\n        if (!f(this.matrix[r][c], r, c)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public hasDimensions(rows: number, cols: number): boolean {\r\n    return this.rows === rows && this.cols === cols;\r\n  }\r\n\r\n  public isSquareMatrix(): boolean {\r\n    return this.rows === this.cols;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the matrix is a square matrix that has identical values on its diagonal.\r\n   */\r\n  public isScalarMatrix(): boolean {\r\n    if (!this.isSquareMatrix()) return false;\r\n    const val = this.matrix[0][0];\r\n    for (let i = 1; i < this.rows; i++) {\r\n      if (this.matrix[i][i] !== val) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public isZeroMatrix(): boolean {\r\n    return this.every((value: number) => value === 0);\r\n  }\r\n\r\n  /**\r\n   * Performs dot product of the matrix with another given matrix.\r\n   */\r\n  public dotProduct(other: Matrix): Matrix {\r\n    if (this.cols !== other.rows) {\r\n      throw new Error(\r\n        'A*B dot product not possible unless the number of columns in A and number of rows in B are the same.',\r\n      );\r\n    }\r\n    const rows = this.rows;\r\n    const cols = other.cols;\r\n    const steps = this.cols;\r\n    const result = new Matrix(rows, cols);\r\n    for (let r = 0; r < rows; r++) {\r\n      for (let c = 0; c < cols; c++) {\r\n        for (let step = 0; step < steps; step++) {\r\n          result.matrix[r][c] += this.matrix[r][step] * other.matrix[step][c];\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","/**\n * Determine wheter a given object is a prototype-object (obj.constructor.prototype === obj).\n */\nexport function isPrototype(value: any): boolean {\n  if (!isObject(value)) return false;\n  if (!('constructor' in value)) return false;\n  return value.constructor.prototype === value;\n}\n\n/**\n * Determine wheter the argument is a Object (is typeof object but not null).\n */\nexport function isObject(value: any): boolean {\n  return value !== null && typeof value === 'object';\n}\n\n/**\n * Determine if value is a constructor function\n */\nexport function isConstructor(value: any): boolean {\n  return (\n    typeof value === 'function' &&\n    'prototype' in value &&\n    isPrototype(value.prototype) &&\n    value === value.prototype.constructor\n  );\n}\n","import { isConstructor, isPrototype } from './validation';\r\n\r\n/**\r\n * Set multiple 'enumerable' property descriptor attributes of the target object to true.\r\n * @param object The target object.\r\n * @param propertyName The property names to be affected.\r\n */\r\nexport function setEnumerable<T>(object: T, ...propertyNames: string[]): void {\r\n  for (const propertyName of propertyNames) {\r\n    Object.defineProperty(object, propertyName, { enumerable: true });\r\n  }\r\n}\r\n\r\n/**\r\n * Set multiple 'enumerable' property descriptor attributes of the target object to false.\r\n * @param object The target object.\r\n * @param propertyName The property names to be affected.\r\n */\r\nexport function setNonEnumerable<T>(object: T, ...propertyNames: string[]): void {\r\n  for (const propertyName of propertyNames) {\r\n    Object.defineProperty(object, propertyName, { enumerable: false });\r\n  }\r\n}\r\n\r\n/**\r\n * Set multiple 'writable' property descriptor attributes of the target object to true.\r\n * @param object The target object.\r\n * @param propertyName The property names to be affected.\r\n */\r\nexport function setWritable<T>(object: T, ...propertyNames: string[]): void {\r\n  for (const propertyName of propertyNames) {\r\n    Object.defineProperty(object, propertyName, { writable: true });\r\n  }\r\n}\r\n\r\n/**\r\n * Set multiple 'writable' property descriptor attributes of the target object to false.\r\n * @param object The target object.\r\n * @param propertyName The property names to be affected.\r\n */\r\nexport function setNonWritable<T>(object: T, ...propertyNames: string[]): void {\r\n  for (const propertyName of propertyNames) {\r\n    Object.defineProperty(object, propertyName, { writable: false });\r\n  }\r\n}\r\n\r\n/**\r\n * Set multiple 'configurable' property descriptor attributes of the target object to false.\r\n * @param object The target object.\r\n * @param propertyName The property names to be affected.\r\n */\r\nexport function setNonConfigurable<T>(object: T, ...propertyNames: string[]): void {\r\n  for (const propertyName of propertyNames) {\r\n    Object.defineProperty(object, propertyName, { configurable: false });\r\n  }\r\n}\r\n\r\n/**\r\n * Set the 'enumerable' property descriptor attributes on the target object to false for all property names that start with '_' (underscore).\r\n * @param object The target object.\r\n */\r\nexport function setNonEnumerablePrivateProperties(object: Record<string, any>): void {\r\n  setNonEnumerable(object, ...Object.keys(object).filter((key) => key.charAt(0) === '_'));\r\n}\r\n\r\n/**\r\n * Iterate the prototype chain of a given object.\r\n * @example\r\n * ```js\r\n * class A {}\r\n * class B extends A {}\r\n * class C extends B {}\r\n * const instance = new C()\r\n *\r\n * iteratePrototypeChain(C)\r\n * //=> [ C, B, A, Function.prototype, Object.prototype]\r\n *\r\n * iteratePrototypeChain(C.prototype)\r\n * //=> [C.prototype, B.prototype, A.prototype, Object.prototype]\r\n *\r\n * iteratePrototypeChain(instance)\r\n * //=> [instance, C.prototype, B.prototype, A.prototype, Object.prototype]\r\n * ```\r\n */\r\nexport function* iteratePrototypeChain(object: Record<string, any>): Generator<Record<string, any>> {\r\n  if (object == null) return;\r\n  if (\r\n    // if the below false, then object must be an instance\r\n    !isPrototype(object) &&\r\n    !isConstructor(object) &&\r\n    // the two above depend on checking that typeof object is 'object',\r\n    // so this last check is in case of arrow functions and generator functions\r\n    object !== Function.prototype\r\n  ) {\r\n    yield object;\r\n    object = object.constructor.prototype;\r\n  }\r\n  let objectOrNull: Object | null = object;\r\n  while (objectOrNull) {\r\n    yield objectOrNull;\r\n    objectOrNull = Reflect.getPrototypeOf(objectOrNull);\r\n  }\r\n}\r\n\r\n// G:\\My Drive\\dev\\dev\\dev\\src\\object\\iterate-object.js\r\n","import { iteratePrototypeChain, setNonEnumerablePrivateProperties } from './object';\n\nconst hasCreatedFirstInstance: WeakSet<Function> = new WeakSet();\n\n/**\n * Abstract class that other classes can inherit from to gain various handy functionality.\n */\nexport abstract class Base {\n  constructor() {\n    this.onFirstInstance();\n  }\n\n  private onFirstInstance() {\n    if (!hasCreatedFirstInstance.has(this.constructor)) {\n      hasCreatedFirstInstance.add(this.constructor);\n      this.assertInterfaceStaticMembers('IRevivableJSON', ['toJSON'], ['fromJSON']);\n    }\n  }\n\n  private assertInterfaceStaticMembers(\n    interfaceName: string,\n    requiredPropertyNames: Array<string>,\n    requiredStaticProperties: Array<string>,\n  ) {\n    const found = new Set();\n    for (const proto of iteratePrototypeChain(this)) {\n      if (proto !== Object.prototype) {\n        for (const key of requiredPropertyNames) {\n          if (Object.hasOwn(proto, key)) {\n            found.add(key);\n          }\n        }\n      }\n    }\n    const implementsInterface = found.size === requiredPropertyNames.length;\n    if (implementsInterface) {\n      for (const staticMember of requiredStaticProperties) {\n        if (!Object.hasOwn(this.constructor, staticMember)) {\n          throw new Error(\n            `Interface ${interfaceName} requires class ${this.constructor.name} to implement static member: ${staticMember}`,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Make the properties with property names that start with an underscore non-enumerable.\n   */\n  protected setNonEnumerablePrivateProperties(): void {\n    setNonEnumerablePrivateProperties(this);\n  }\n\n  protected assertNoAmbiguousOptions(options: Record<string, any>, optionKeyPairs: Array<[string, string]>) {\n    for (const [key1, key2] of optionKeyPairs) {\n      if (options[key1] !== undefined && options[key2] !== undefined) {\n        throw new Error(`Cannot use the '${key1}' option and the '${key2}' option simultanously.`);\n      }\n    }\n  }\n\n  protected assertNoOptionsRequireMissingOptions(\n    options: Record<string, any>,\n    optionKeyPairs: Array<[string, string]>,\n  ) {\n    for (const [key1, key2] of optionKeyPairs) {\n      if (options[key1] !== undefined && options[key2] === undefined) {\n        throw new Error(`Cannot use the '${key1}' option without the '${key2}' option.`);\n      }\n    }\n  }\n}\n","export type RexecOutput = {\r\n  index: number;\r\n  match: string;\r\n  groups: Record<string, any>;\r\n  lastIndex: number;\r\n};\r\n\r\n/**\r\n * Easily perform regex 'exec' on a string. An iterable is returned which steps through the exec process and yields all\r\n * the details you might need.\r\n * @param regex - The regular expression object\r\n * @param str - The string to perform the operation on\r\n * @example\r\n * ```js\r\n * const regex = /(?<group1>a)|(?<group2>d)/g\r\n * const str = 'Anthony wants a girlfriend.'\r\n * console.log([...rexec(regex, str)])\r\n * // [\r\n * // \t{\r\n * //     index: 9,\r\n * //     match: 'a',\r\n * //     groups: { g1: 'a', g2: undefined },\r\n * //     lastIndex: 10,\r\n * //   },\r\n * //   {\r\n * //     index: 14,\r\n * //     match: 'a',\r\n * //     groups: { g1: 'a', g2: undefined },\r\n * //     lastIndex: 15,\r\n * //   },\r\n * //   {\r\n * //     index: 25,\r\n * //     match: 'd',\r\n * //     groups: { g1: undefined, g2: 'd' },\r\n * //     lastIndex: 26,\r\n * //   },\r\n * // ]\r\n * ```\r\n */\r\nexport function* rexec(regex: RegExp, str: string): Generator<RexecOutput> {\r\n  let match;\r\n  while ((match = regex.exec(str)) !== null) {\r\n    yield {\r\n      index: match.index,\r\n      match: match[0],\r\n      groups: Object.assign({}, match.groups),\r\n      lastIndex: regex.lastIndex,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an array of named groups defined inside a RegExp instance.\r\n * @param re RegExp instance to extract named groups from.\r\n */\r\nexport function regexGetGroupNames(re: RegExp): Array<string> {\r\n  const names = [];\r\n  for (const res of rexec(/\\(\\?<(?<name>\\w+)>/g, re.toString())) {\r\n    names.push(res.groups.name);\r\n  }\r\n  return names;\r\n}\r\n\r\n/**\r\n * Escapes a string so it can be used in a regular expression.\r\n */\r\nexport function regexEscapeString(str: string): string {\r\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\r\n}\r\n","// const REGEX_VALID_A = /^[A-Z]+$/g;\nconst alphaToColMap: Map<string, number> = new Map();\n\n/**\n * Convert spreadsheet column letter(s) to column-number\n * @param A - Column letter\n * @param zeroIndexed - Whether or not column number start at one or zero.\n */\nexport function letterToCol(A: string, zeroIndexed = false): number {\n  A = A.toUpperCase();\n  const fromMem = alphaToColMap.get(A);\n  if (fromMem) return fromMem;\n  // if (REGEX_VALID_A.test(A)) throw new Error(`Invalid column letter: ${A}`);\n  let col = 0;\n  const length = A.length;\n  for (let i = 0; i < length; i++) {\n    col += (A.charCodeAt(i) - 64) * Math.pow(26, length - i - 1);\n  }\n  return col - (zeroIndexed ? 1 : 0);\n}\n","import { rexec } from '../../regex';\nimport { letterToCol } from './letterToCol';\n\nconst REGEX_VALID_A1 = /^(?<a>[A-Z]+)(?<n>[1-9]+)$/g;\n\n/**\n * Convert spreadsheet A1-notation to [column, row].\n * @param A1 - A1-notation string.\n * @param zeroIndexed - Whether or not column and row numbers start at one or zero.\n */\nexport function A1ToColRow(A1: string, zeroIndexed = false): Array<number> {\n  A1 = A1.toUpperCase();\n  const matches = [...rexec(REGEX_VALID_A1, A1)];\n  if (!matches.length) throw new Error(`Invalid A1 string: ${A1}`);\n  const adjust = zeroIndexed ? 1 : 0;\n  return [\n    letterToCol(matches[0].groups.a) - adjust,\n    parseInt(matches[0].groups.n) - adjust,\n  ];\n}\n","const colToAlphaMap: Map<number, string> = new Map();\n\n/**\n * Convert a spreadsheet column number to a column letter.\n * @param col - Column number\n * @param zeroIndexed - Whether or not column number start at one or zero.\n */\nexport function colToLetter(col: number, zeroIndexed = false): string {\n  if (zeroIndexed) col++;\n  const fromMem = colToAlphaMap.get(col);\n  if (fromMem) return fromMem;\n  if (!Number.isInteger(col))\n    throw new Error(`Expected col to be an integer. Got: ${col}`);\n  if (col < 1)\n    throw new Error(`Expected col to be greater than zero. Got: ${col}`);\n  let letter = '';\n  let temp;\n  while (col > 0) {\n    temp = (col - 1) % 26;\n    letter = String.fromCharCode(temp + 65) + letter;\n    col = (col - temp - 1) / 26;\n  }\n  return letter;\n}\n","import { IRevivableJSON } from '../';\nimport { arr2dToCSV, arrEvery, arrMapMutable } from '../../array';\nimport { Base } from '../../Base';\nimport { A1ToColRow } from '../../spreadsheet';\nimport { letterToCol } from '../../spreadsheet/src/letterToCol';\n\n/**\n * Constructor options for the Table class.\n */\nexport interface ITableOptions<T> {\n  /**\n   * 2D array to build table from.\n   * All rows must be the same length.\n   * When using this option, the 'columns' and 'rows' options are not allowed.\n   */\n  data?: Array<Array<T>>;\n  /**\n   * Intepret the first row of passed data as column headers/names (see TableOptions.data property).\n   * When performing lookups in the table from indices or coordinates, headers are ignored, ie. not counted.\n   * If the 'data' option is not used, this option is not allowed.\n   * If the 'columnHeaders' option is used, this option is not allowed.\n   */\n  extractColumnHeaders?: boolean;\n  /**\n   * Intepret the first element of every row of passed data as row headers/names (see TableOptions.data property).\n   * When performing lookups in the table from indices or coordinates, headers are ignored, ie. not counted.\n   * If the 'data' option is not used, this option is not allowed.\n   * If the 'rowHeaders' option is used, this option is not allowed.\n   */\n  extractRowHeaders?: boolean;\n  /**\n   * Define column headers/names.\n   * Must be of same length as entered in the 'columns' option.\n   * When performing lookups in the table from indices or coordinates, headers are ignored, ie. not counted.\n   * When using row headers simultaneously, this array will need to be of length one higher as the first element is intepreted as the column header for the row headers column.\n   */\n  columnHeaders?: Array<string>;\n  /**\n   * Define column headers/names.\n   * Must be of same length as entered in the 'columns' option.\n   * When performing lookups in the table from indices or coordinates, headers are ignored, ie. not counted.\n   */\n  rowHeaders?: Array<string>;\n  /**\n   * Number of columns in the table.\n   * This option is not allowed when the 'data' or 'columnHeaders' properties are being used.\n   * TypeScript: Type safety consideration: Please note that when initializing an empty Table, it is full of 'undefined' values even if the table is specifically typed to not allow 'undefined'. TypeScript's static type-checking cannot see this.\n   */\n  columns?: number;\n  /**\n   * Number of rows in the table.\n   * This option is not allowed when the 'data' or 'rowHeaders' properties are being used.\n   * TypeScript: Type safety consideration: Please note that when initializing an empty Table, it is full of 'undefined' values even if the table is specifically typed to not allow 'undefined'. TypeScript's static type-checking cannot see this.\n   */\n  rows?: number;\n}\n\nexport type TableSerializedForm<T> = {\n  columnHeaders: Array<string>;\n  rowHeaders: Array<string>;\n  data: Array<Array<T>>;\n};\n\n/**\n * Two-dimensional table class supporting column and row headers.\n */\nexport class Table<T> extends Base implements IRevivableJSON<TableSerializedForm<T>> {\n  protected _columnHeaders?: Array<string>;\n  protected _rowHeaders?: Array<string>;\n  protected _data: Array<Array<T>> = [];\n\n  /**\n   * Creates a Table instance from CSV string data.\n   * @param csv CSV data string\n   * @param delimiter csv delimiter\n   * @param options TableOptions constructor options.\n   */\n  public static fromCSV<T>(csv: string, delimiter = ';', options: ITableOptions<T | string> = {}): Table<T | string> {\n    options.data = csv\n      .split('\\n')\n      .filter((line) => line.length)\n      .map((line) => line.trim().split(delimiter));\n    return new Table(options);\n  }\n\n  /**\n   * Revive a stringified Table object.\n   * @param json a stringified Table object.\n   */\n  public static fromJSON<T>(json: string): Table<T> {\n    return new Table(JSON.parse(json));\n  }\n\n  constructor(options: ITableOptions<T> = {}) {\n    super();\n    this.validateOptions(options);\n    this.handleOptions(options);\n    this.validateData();\n    this.setNonEnumerablePrivateProperties();\n  }\n\n  /**\n   * Gets the number of cols in the table, not including headers.\n   */\n  public get columns(): number {\n    return this._data[0].length;\n  }\n\n  /**\n   * Gets the number of rows in the table, not including headers.\n   */\n  public get rows(): number {\n    return this._data.length;\n  }\n\n  /**\n   * Gets the column headers.\n   */\n  public get columnHeaders(): Array<string> {\n    if (!this._columnHeaders) {\n      throw new Error('No column headers are defined for this table.');\n    }\n    return this._columnHeaders ? this._columnHeaders.slice() : [];\n  }\n\n  /**\n   * Gets the row headers.\n   */\n  public get rowHeaders(): Array<string> {\n    if (!this._rowHeaders) {\n      throw new Error('No row headers are defined for this table.');\n    }\n    return this._rowHeaders ? this._rowHeaders.slice() : [];\n  }\n\n  /**\n   * Returns a value at a given (row, col) position.\n   * @param column Column index\n   * @param row Row index\n   * @param spreadsheetNotation Interpret row and col as spreadsheet coordinates, eg. (\"A\",\"1\")\n   */\n  public get(column: number | string, row: number | string, spreadsheetNotation = false): T {\n    [column, row] = this.normalizeColRow(column, row, spreadsheetNotation);\n    return this._data[row][column];\n  }\n\n  /**\n   * Inserts a given value at a given (row, col) position.\n   * @param column Column index\n   * @param row Row index\n   * @param value The value to insert\n   * @param spreadsheetNotation Interpret row and col as spreadsheet coordinates, eg. (\"A\",\"1\")\n   */\n  public set(column: number | string, row: number | string, value: T, spreadsheetNotation = false): Table<T> {\n    [column, row] = this.normalizeColRow(column, row, spreadsheetNotation);\n    this._data[row][column] = value;\n    return this;\n  }\n\n  /**\n   * Deletes a column in the table.\n   * @param column Column index\n   * @param spreadsheetNotation Interpret row and col as spreadsheet coordinates, eg. (\"A\",\"1\")\n   */\n  public removeColumn(column: number | string, spreadsheetNotation = false): Table<T> {\n    column = this.normalizeCol(column, spreadsheetNotation);\n    arrMapMutable(this._data, (row) => {\n      row.splice(column, 1);\n      return row;\n    });\n    if (this._columnHeaders) {\n      this._columnHeaders.splice(column + (this._rowHeaders ? 1 : 0), 1);\n    }\n    return this;\n  }\n\n  /**\n   * Deletes a row in the table.\n   * @param row Row index\n   * @param spreadsheetNotation Interpret row and col as spreadsheet coordinates, eg. (\"A\",\"1\")\n   */\n  public removeRow(row: number | string, spreadsheetNotation = false): Table<T> {\n    row = this.normalizeRow(row, spreadsheetNotation);\n    this._data.splice(row, 1);\n    if (this._rowHeaders) this._rowHeaders.splice(row, 1);\n    return this;\n  }\n\n  /**\n   * Gets the index of a given column header.\n   * Even if row headers are defined, this is not considered a column and is ignored in this search.\n   */\n  public indexOfColumnHeader(header: string): number {\n    if (!this._columnHeaders) {\n      throw new Error('No column headers are defined for this table.');\n    }\n    return this._columnHeaders.indexOf(header) - (this._rowHeaders ? 1 : 0);\n  }\n\n  /**\n   * Gets the index of a given row header.\n   */\n  public indexOfRowHeader(header: string): number {\n    if (!this._rowHeaders) {\n      throw new Error('No row headers are defined for this table.');\n    }\n    return this._rowHeaders.indexOf(header);\n  }\n\n  /**\n   * Returns the table as a two-dimensional array, including row and column headers..\n   */\n  public toArray(): Array<Array<T | string>> {\n    const result: Array<Array<T | string>> = [];\n    if (this._columnHeaders) {\n      result.push(this.columnHeaders);\n    }\n    for (let i = 0; i < this.rows; i++) {\n      const row: Array<T | string> = this._data[i].slice();\n      if (this._rowHeaders) row.unshift(this._rowHeaders[i]);\n      result.push(row);\n    }\n    return result;\n  }\n\n  /**\n   * Returns the table as a two-dimensional array, without row and column headers.\n   */\n  public toArrayDataOnly(): Array<Array<T>> {\n    const result: Array<Array<T>> = [];\n    for (let i = 0; i < this.rows; i++) {\n      result.push(this._data[i].slice());\n    }\n    return result;\n  }\n\n  /**\n   * Returns the table as a CSV string.\n   * @param delimiter csv delimiter\n   */\n  public toCSV(delimiter = ';'): string {\n    return arr2dToCSV(this.toArray(), delimiter);\n  }\n\n  /**\n   * Override of the native toJSON method. When parsing the returned json string, it can be revived as a Table object when using the static Table.fromJSON method.\n   */\n  public toJSON(): TableSerializedForm<T> {\n    return {\n      columnHeaders: this._columnHeaders || [],\n      rowHeaders: this._rowHeaders || [],\n      data: this._data,\n    };\n  }\n\n  protected validateOptions(options: ITableOptions<T>) {\n    this.assertNoAmbiguousOptions(options, [\n      ['extractColumnHeaders', 'columnHeaders'],\n      ['extractRowHeaders', 'rowHeaders'],\n      ['columns', 'data'],\n      ['rows', 'data'],\n      ['columns', 'columnHeaders'],\n      ['rows', 'rowHeaders'],\n    ]);\n    this.assertNoOptionsRequireMissingOptions(options, [\n      ['extractColumnHeaders', 'data'],\n      ['extractRowHeaders', 'data'],\n    ]);\n  }\n\n  protected handleOptions(options: ITableOptions<T>): void {\n    options = Object.assign({}, options);\n\n    if (options.extractColumnHeaders && options.data) {\n      options.data = options.data.slice();\n      options.columnHeaders = options.data.splice(0, 1)[0].map((h) => h + '');\n    }\n\n    if (options.extractRowHeaders && options.data) {\n      options.data = options.data.map((row) => row.slice());\n      options.rowHeaders = [];\n      for (let i = 0; i < options.data.length; i++) {\n        options.rowHeaders.push(options.data[i].splice(0, 1)[0] + '');\n      }\n    }\n\n    if (options.rowHeaders) {\n      this._rowHeaders = options.rowHeaders.slice();\n      options.rows = options.rowHeaders.length;\n    } else if (options.rows === undefined) {\n      options.rows = 1;\n    } else {\n      this.validateRowMin(options.rows);\n    }\n\n    if (options.columnHeaders) {\n      this._columnHeaders = options.columnHeaders.slice();\n      options.columns = options.columnHeaders.length - (options.rowHeaders ? 1 : 0);\n    } else if (options.columns === undefined) {\n      options.columns = 1;\n    } else {\n      this.validateColMin(options.columns);\n    }\n\n    if (options.data) {\n      for (let i = 0; i < options.data.length; i++) {\n        this._data.push(options.data[i].slice());\n      }\n    } else {\n      this.buildEmptyTableWithDimensions(options.rows, options.columns);\n    }\n  }\n\n  protected validateData(): void {\n    if (this._columnHeaders) {\n      const targetLength = this._columnHeaders.length - (this._rowHeaders ? 1 : 0);\n      if (\n        !arrEvery(\n          this._data.map((row) => row.length),\n          (rowLength) => rowLength === targetLength,\n        )\n      ) {\n        throw new Error('Expected all rows to be of same length.');\n      }\n    }\n    if (this._rowHeaders && this._rowHeaders.length !== this._data.length) {\n      throw new Error('Expected a row header for each row.');\n    }\n  }\n\n  protected buildEmptyTableWithDimensions(rows: number, cols: number): void {\n    for (let i = 0; i < rows; i++) {\n      this._data.push(new Array(cols));\n    }\n  }\n\n  protected validateRowMin(rows: number): void {\n    if (rows < 1) {\n      throw new Error('Expected rows to be integer larger than 0 but got: ' + rows);\n    }\n    if (!Number.isInteger(rows)) {\n      throw new Error('Expected rows to be integer an integer.');\n    }\n  }\n\n  protected validateColMin(cols: number): void {\n    if (cols < 1) {\n      throw new Error('Expected columns to be integer larger than 0 but got: ' + cols);\n    }\n    if (!Number.isInteger(cols)) {\n      throw new Error('Expected columns to be integer an integer.');\n    }\n  }\n\n  protected ensureValidRowIndex(row: number | string): number {\n    if (typeof row === 'string') {\n      if (!this._rowHeaders) {\n        throw new Error('Cannot pass row as string when no rowHeaders are defined.');\n      }\n      row = this._rowHeaders.indexOf(row);\n      if (row === -1) {\n        throw new Error('Row not found in rowHeaders.');\n      }\n    } else this.validateRowMin(row + 1);\n    return row;\n  }\n\n  protected ensureValidColIndex(col: number | string): number {\n    if (typeof col === 'string') {\n      if (!this._columnHeaders) {\n        throw new Error('Cannot pass col as string when no columnHeaders are defined.');\n      }\n      col = this._columnHeaders.indexOf(col) - (this._rowHeaders ? 1 : 0);\n      if (col < 0) {\n        throw new Error('Col not found in columnHeaders.');\n      }\n    } else this.validateColMin(col + 1);\n    return col;\n  }\n\n  protected normalizeCol(col: number | string, spreadsheetNotation: boolean): number {\n    if (spreadsheetNotation) {\n      col = letterToCol(String(col), true);\n    }\n    return this.ensureValidColIndex(col);\n  }\n\n  protected normalizeRow(row: number | string, spreadsheetNotation: boolean): number {\n    if (spreadsheetNotation) {\n      row = Number(row);\n    }\n    return this.ensureValidRowIndex(row);\n  }\n\n  protected normalizeColRow(col: number | string, row: number | string, spreadsheetNotation: boolean): number[] {\n    if (spreadsheetNotation) {\n      [col, row] = A1ToColRow(String(col) + String(row), true);\n    }\n    return [this.ensureValidColIndex(col), this.ensureValidRowIndex(row)];\n  }\n}\n","import numberFormat from 'format-number';\r\n\r\nconst eu = new Map();\r\nconst us = new Map();\r\n\r\n/**\r\n * Formats a number input to a string representation in the style of 5.000.000,00\r\n * @param input number to format\r\n * @param decimalPlaces number of decimal places to return. Will pad string with zeroes to ensure this length.\r\n */\r\nexport function numFormatEU(input: number, decimalPlaces = 0): string {\r\n  let formatter = eu.get(decimalPlaces);\r\n  if (!formatter) {\r\n    formatter = numberFormat({\r\n      truncate: decimalPlaces,\r\n      padRight: decimalPlaces,\r\n      integerSeparator: '.',\r\n      decimal: ',',\r\n    });\r\n    eu.set(decimalPlaces, formatter);\r\n  }\r\n  return formatter(input);\r\n}\r\n\r\n/**\r\n * Formats a number input to a string representation in the style of 5,000,000.00\r\n * @param input number to format\r\n * @param decimalPlaces number of decimal places to return. Will pad string with zeroes to ensure this length.\r\n */\r\nexport function numFormatUS(input: number, decimalPlaces = 0): string {\r\n  let formatter = us.get(decimalPlaces);\r\n  if (!formatter) {\r\n    formatter = numberFormat({\r\n      truncate: decimalPlaces,\r\n      padRight: decimalPlaces,\r\n      integerSeparator: ',',\r\n      decimal: '.',\r\n    });\r\n    us.set(decimalPlaces, formatter);\r\n  }\r\n  return formatter(input);\r\n}\r\n\r\nconst POW10 = [1, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];\r\n\r\n/**\r\n * Approximate the logarithm base 10 of a small integer.\r\n * @param x - The integer to approximate the logarithm of.\r\n */\r\nexport function numApproximateLog10(x: number): number {\r\n  if (x < POW10[5]) {\r\n    if (x < POW10[2]) {\r\n      return x < POW10[1] ? 0 : 1;\r\n    }\r\n    if (x < POW10[4]) {\r\n      return x < POW10[3] ? 2 : 3;\r\n    }\r\n    return 4;\r\n  }\r\n  if (x < POW10[7]) {\r\n    return x < POW10[6] ? 5 : 6;\r\n  }\r\n  if (x < POW10[9]) {\r\n    return x < POW10[8] ? 7 : 8;\r\n  }\r\n  return 9;\r\n}\r\n","import { regexEscapeString } from './regex';\r\n\r\n/**\r\n * Inserts a provided string before and after a string.\r\n * @param input - input string\r\n * @param wrap - string to place before and after\r\n * @example\r\n * ```js\r\n * expect(util.strWrapIn('input', '#')).toBe('#input#');\r\n * ```\r\n */\r\nexport function strWrapIn(input: string, wrap: string): string {\r\n  return wrap + input + wrap;\r\n}\r\n\r\n/**\r\n * Inserts provided strings before and after a string.\r\n * @param input - input string\r\n * @param before - string to place before\r\n * @param after - string to place after\r\n * @example\r\n * ```js\r\n * expect(util.strWrapBetween('input', '#', '&')).toBe('#input&');\r\n * ```\r\n */\r\nexport function strWrapBetween(\r\n  input: string,\r\n  before: string,\r\n  after: string,\r\n): string {\r\n  return before + input + after;\r\n}\r\n\r\n/**\r\n * Wraps a string in brackets.\r\n * @param input - input string\r\n * @example\r\n * ```js\r\n * expect(util.strWrapInBrackets('input')).toBe('[input]');\r\n * ```\r\n */\r\nexport function strWrapInBrackets(input: string): string {\r\n  return '[' + input + ']';\r\n}\r\n\r\n/**\r\n * Wraps a string in angle brackets.\r\n * @param input - input string\r\n * @example\r\n * ```js\r\n * expect(util.strWrapInAngleBrackets('input')).toBe('<input>');\r\n * ```\r\n */\r\nexport function strWrapInAngleBrackets(input: string): string {\r\n  return '<' + input + '>';\r\n}\r\n\r\n/**\r\n * Wraps a string in braces.\r\n * @param input - input string\r\n * @example\r\n * ```js\r\n * expect(util.strWrapInBraces('input')).toBe('{input}');\r\n * ```\r\n */\r\nexport function strWrapInBraces(input: string): string {\r\n  return '{' + input + '}';\r\n}\r\n\r\n/**\r\n * Wraps a string in parenthesis.\r\n * @param input - input string\r\n * @example\r\n * ```js\r\n * expect(util.strWrapInParenthesis('input')).toBe('(input)');\r\n * ```\r\n */\r\nexport function strWrapInParenthesis(input: string): string {\r\n  return '(' + input + ')';\r\n}\r\n\r\n/**\r\n * Wraps a string in parenthesis.\r\n * @param input - input string\r\n * @example\r\n * ```js\r\n * expect(util.strWrapInSingleQuotes('input')).toBe(\"'input'\");\r\n * ```\r\n */\r\nexport function strWrapInSingleQuotes(input: string): string {\r\n  return \"'\" + input + \"'\";\r\n}\r\n\r\n/**\r\n * Wraps a string in parenthesis.\r\n * @param input - input string\r\n * @example\r\n * ```js\r\n * expect(util.strWrapInDoubleQuotes('input')).toBe('\"input\"');\r\n * ```\r\n */\r\nexport function strWrapInDoubleQuotes(input: string): string {\r\n  return '\"' + input + '\"';\r\n}\r\n\r\n/**\r\n * Returns whether the string is lower case.\r\n * @param input - input string\r\n * @example\r\n * ```js\r\n * strIsLowerCase('abc')\r\n * //=> true\r\n *\r\n * strIsLowerCase('ABC')\r\n * //=> false\r\n * ```\r\n */\r\nexport function strIsLowerCase(input: string): boolean {\r\n  return input === input.toLowerCase();\r\n}\r\n\r\n/**\r\n * Returns whether the string is upper case.\r\n * @param input - input string\r\n * @example\r\n * ```js\r\n * strIsUpperCase('abc')\r\n * //=> false\r\n *\r\n * strIsUpperCase('ABC')\r\n * //=> true\r\n * ```\r\n */\r\nexport function strIsUpperCase(input: string): boolean {\r\n  return input === input.toUpperCase();\r\n}\r\n\r\n/**\r\n * Returns an array of words in the string\r\n * @param input - input string\r\n * @example\r\n * ```js\r\n * strToWords('How are you?')\r\n * //=> ['How', 'are', 'you']\r\n * ```\r\n */\r\nexport function strToWords(input: string): Array<string> {\r\n  return input.match(regexIsWord) || [];\r\n}\r\n\r\nconst regexIsNumber = /\\d((\\.|\\d)*)?/g;\r\nconst regexIsWord = /\\b[^\\W]+/g;\r\n/**\r\n * Returns an array of words in the string\r\n * @param input - input string\r\n * @example\r\n * ```js\r\n * strSplitWordByCamelCase('someCamelCase')\r\n * //=> ['some', 'Camel', 'Case']\r\n * ```\r\n */\r\nexport function strSplitWordByCamelCase(word: string): Array<string> {\r\n  function isCamelCaseWordBreakIndex(word: string, index: number) {\r\n    return (\r\n      strIsLowerCase(word[index - 1]) &&\r\n      strIsUpperCase(word[index]) &&\r\n      !regexIsNumber.test(word[index - 1]) &&\r\n      !regexIsNumber.test(word[index])\r\n    );\r\n  }\r\n  const result = [];\r\n  const lastCharIndex = word.length - 1;\r\n  let lastCamelCaseBreakIndex = 0;\r\n  let foundCamelCase = false;\r\n  for (let i = 1; i < word.length; i++) {\r\n    if (foundCamelCase && i === lastCharIndex) {\r\n      // last char\r\n      const sub = word.substring(lastCamelCaseBreakIndex);\r\n      if (sub) result.push(sub);\r\n      continue;\r\n    }\r\n    if (isCamelCaseWordBreakIndex(word, i)) {\r\n      const sub = word.substring(lastCamelCaseBreakIndex, i);\r\n      if (!sub) continue;\r\n      result.push(sub);\r\n      lastCamelCaseBreakIndex = i;\r\n      foundCamelCase = true;\r\n    }\r\n  }\r\n  // if no splits needed, just return the word as it was\r\n  if (!foundCamelCase) {\r\n    result.push(word);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Count occurances of a character within a given string.\r\n * @param input - The string to search\r\n * @param char - The character to find\r\n */\r\nexport function strCountCharOccurances(input: string, char: string): number {\r\n  if (char.length !== 1) {\r\n    throw new Error(\r\n      'Expected char to be a single character string of length 1.',\r\n    );\r\n  }\r\n  let result = 0;\r\n  for (const c of input) {\r\n    if (c === char) {\r\n      result++;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Returns a given number of contatenations of a given input string.\r\n * @param input - input string\r\n * @param n - Number of repetitions of the input string\r\n */\r\nexport function strRepeat(input: string, n: number): string {\r\n  return new Array(n).fill(input).join('');\r\n}\r\n\r\n/**\r\n * Takes a multiline string and performs a left side trim of whitespace on each line.\r\n * @param input - input string\r\n */\r\nexport function strLinesTrimLeft(input: string): string {\r\n  return input.replace(/\\n\\r?\\s+/gm, '\\n');\r\n}\r\n\r\n/**\r\n * Takes a multiline string and performs a right side trim of whitespace on each line.\r\n * @param input - input string\r\n */\r\nexport function strLinesTrimRight(input: string): string {\r\n  return input.replace(/\\s+\\n/gm, '\\n');\r\n}\r\n\r\n/**\r\n * Takes a multiline string and removes lines that are empty or only contain whitespace.\r\n * @param input - input string\r\n */\r\nexport function strLinesRemoveEmpty(input: string): string {\r\n  return input\r\n    .replace(/\\n\\r?\\s*\\n\\r?/gm, '\\n')\r\n    .trimStart()\r\n    .trimEnd();\r\n}\r\n\r\n/**\r\n * Very crude, simple, fast code formatting of minified code.\r\n * Only works when input code:\r\n * - is minified\r\n * - is scoped with brackets\r\n * - expressions end with semicolon\r\n * - has no string literals containing any of these characters: '{', '}', ';'.\r\n * @param input The minified source code\r\n * @param indent The string to use as indentation\r\n */\r\nexport function strPrettifyMinifiedCode(input: string, indent = '  '): string {\r\n  const getIndents = (n: number) => strRepeat('\\t', n);\r\n  const fixIndents = (s: string) => {\r\n    return s.replace(/\\t +/g, '\\t').replace(/\\t/g, indent);\r\n  };\r\n  let depth = 0;\r\n  const arr = Array.from(input).map((c) => {\r\n    if (c === '{') {\r\n      depth++;\r\n      return '{\\n' + getIndents(depth);\r\n    } else if (c === '}') {\r\n      depth--;\r\n      return '\\n' + getIndents(depth) + '}\\n' + getIndents(depth);\r\n    } else if (c === ';') {\r\n      return ';\\n' + getIndents(depth);\r\n    } else return c;\r\n  });\r\n  return fixIndents(strLinesTrimRight(strLinesRemoveEmpty(arr.join(''))));\r\n}\r\n\r\n/**\r\n * In a given string, replace all occurances of a given search string with a given replacement string.\r\n * @param input input string\r\n * @param replace string to find a replace\r\n * @param replaceWith string to replace matches with\r\n * @param flags RegExp flags as single string.\r\n */\r\nexport function strReplaceAll(\r\n  input: string,\r\n  replace: string,\r\n  replaceWith: string,\r\n  flags = 'g',\r\n): string {\r\n  return input.replace(\r\n    new RegExp(regexEscapeString(replace), flags),\r\n    replaceWith,\r\n  );\r\n}\r\n","import Path from 'path';\r\nimport fs from 'fs';\r\nimport { numFormatEU, numFormatUS } from './number';\r\nimport { strCountCharOccurances } from './string';\r\n\r\nexport type MemoryUsageValues = {\r\n  processAllocationMB: number;\r\n  heapAllocationMB: number;\r\n  heapUsedMB: number;\r\n  extenalV8: number;\r\n};\r\n\r\nexport type MemoryUsageValuesFormatted = {\r\n  processAllocationMB: string;\r\n  heapAllocationMB: string;\r\n  heapUsedMB: string;\r\n  extenalV8: string;\r\n};\r\n\r\nconst toIntMB = (n: number) => Math.floor(n * 0.000001);\r\n\r\nconst getMemoryUsageFormatted = (\r\n  format: (n: number) => string,\r\n): MemoryUsageValuesFormatted => {\r\n  const data = process.memoryUsage();\r\n  return {\r\n    processAllocationMB: format(data.rss),\r\n    heapAllocationMB: format(data.heapTotal),\r\n    heapUsedMB: format(data.heapUsed),\r\n    extenalV8: format(data.external),\r\n  };\r\n};\r\n\r\n/**\r\n * Returns an object about the process memory usage for: process allocation, heap allocation, heap, v8.\r\n */\r\nexport function getMemoryUsage(): MemoryUsageValues {\r\n  const data = process.memoryUsage();\r\n  return {\r\n    processAllocationMB: toIntMB(data.rss),\r\n    heapAllocationMB: toIntMB(data.heapTotal),\r\n    heapUsedMB: toIntMB(data.heapUsed),\r\n    extenalV8: toIntMB(data.external),\r\n  };\r\n}\r\n\r\n/**\r\n * Returns an object about the process memory usage for: process allocation, heap allocation, heap, v8.\r\n * The values are formatted strings in the style of 5.000,00\r\n */\r\nexport function getMemoryUsageFormattedEU(): MemoryUsageValuesFormatted {\r\n  return getMemoryUsageFormatted(\r\n    (bytes: number) => `${numFormatEU(bytes * 0.000001, 2)} MB`,\r\n  );\r\n}\r\n\r\n/**\r\n * Returns an object about the process memory usage for: process allocation, heap allocation, heap, v8.\r\n * The values are formatted strings in the style of 5,000.00\r\n */\r\nexport function getMemoryUsageFormattedUS(): MemoryUsageValuesFormatted {\r\n  return getMemoryUsageFormatted(\r\n    (bytes: number) => `${numFormatUS(bytes * 0.000001, 2)} MB`,\r\n  );\r\n}\r\n\r\n/**\r\n * Takes a directory path as a list of directory/folder names from the current working directory and returns it as a full path string.\r\n * @param dirs directory names from the current working directory.\r\n */\r\nexport function getWorkingDirPath(...dirs: Array<string>): string {\r\n  return Path.join(process.cwd(), ...dirs);\r\n}\r\n\r\n/**\r\n * Takes a filepath and returns its utf8 contents as a single string.\r\n * @param path path to the file\r\n */\r\nexport function readFileStringSync(path: string): string {\r\n  return fs.readFileSync(path, 'utf8').toString();\r\n}\r\n\r\n/**\r\n * Normalize a file extension to the form: .[ext]\r\n * Anything before the last \".\" is not returned.\r\n * @param ext file extension\r\n */\r\nexport function normalizeFileExtension(ext: string): string {\r\n  if (ext === '' || ext === '.') return '';\r\n  if (/[<>\"|?*:]/g.test(ext)) {\r\n    throw new Error(\r\n      `Illegal characters in file extension: ${ext}  |  Illegal characters are: <>\"|?:*`,\r\n    );\r\n  }\r\n  if (strCountCharOccurances(ext, '.') === 0) return '.' + ext;\r\n  return ext.substring(ext.lastIndexOf('.'));\r\n}\r\n\r\n/**\r\n * Takes a list of file extensions and returns a filter function that returns true if a filepath/filename passed to it contains one of the given file extensions.\r\n * @param fileExtensions file extensions\r\n */\r\nexport function createFileExtensionFilter(\r\n  ...fileExtensions: Array<string>\r\n): (filepath: string) => boolean {\r\n  if (!fileExtensions.length) return () => true;\r\n  return (filepath: string) => {\r\n    for (const ext of fileExtensions.map(normalizeFileExtension)) {\r\n      if (Path.extname(filepath) === ext) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n}\r\n\r\nexport type ensureValidWindowsPathOptions = {\r\n  extendedMaxLength?: boolean;\r\n  assert?: boolean;\r\n};\r\n\r\n/**\r\n * Check whether a provided windows filesystem path string is valid according to:\r\n * https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\r\n * @param path The path to validate\r\n * @param extendedMaxLength On most versions of windows, the max allowed length of paths has been\r\n * raised.\r\n */\r\nexport function ensureValidWindowsPath(\r\n  path: string,\r\n  options?: ensureValidWindowsPathOptions,\r\n): boolean {\r\n  const throwOrFalse = (msg: string) => {\r\n    if (options && options.assert === true) {\r\n      throw new Error(\r\n        `Invalid windows path. ${msg}  |  input received: ${path}`,\r\n      );\r\n    }\r\n    return false;\r\n  };\r\n\r\n  if (path.length === 0) {\r\n    return throwOrFalse('Path string is length 0.');\r\n  }\r\n\r\n  if (\r\n    strCountCharOccurances(path, '/') > 0 &&\r\n    strCountCharOccurances(path, '\\\\') > 0\r\n  ) {\r\n    return throwOrFalse('Path contains both backslash and forward slash.');\r\n  }\r\n\r\n  const maxLength = (options && options.extendedMaxLength ? 32767 : 260) - 12;\r\n  if (path.length > maxLength) {\r\n    return throwOrFalse(`Maximum length of ${maxLength} exceeded`);\r\n  }\r\n\r\n  let noDriveLetter = path;\r\n  if (/^\\w:(\\\\|\\/)/g.test(path)) {\r\n    noDriveLetter = path.substring(2);\r\n  }\r\n  if (/[<>\"|?*:]/g.test(noDriveLetter)) {\r\n    return throwOrFalse(\r\n      `Illegal characters in: ${path}  |  Illegal characters are: <>\"|?:*`,\r\n    );\r\n  }\r\n\r\n  if (/(\\\\|\\/)(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])((\\\\|\\/)|$)/g.test(path)) {\r\n    return throwOrFalse('Illegal name in path string');\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nimport { Readable } from 'stream';\r\n\r\n/**\r\n * Extension of Node's native Readable class for converting a string into a Readable stream.\r\n */\r\nexport class StringStream extends Readable {\r\n  private str: string;\r\n  private ended: boolean;\r\n\r\n  constructor(str: string) {\r\n    super();\r\n    this.str = str;\r\n    this.ended = false;\r\n  }\r\n\r\n  _read(): void {\r\n    if (!this.ended) {\r\n      process.nextTick(() => {\r\n        this.push(Buffer.from(this.str));\r\n        this.push(null);\r\n      });\r\n      this.ended = true;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Drain a Readable into a string.\r\n * @param stream - a Readable of string chunks\r\n */\r\nexport async function streamToString(stream: Readable): Promise<string> {\r\n  const chunks: string[] = [];\r\n  for await (const chunk of stream) {\r\n    chunks.push(Buffer.from(chunk).toString());\r\n  }\r\n  return chunks.join('');\r\n}\r\n","/**\r\n * A Function class that can be extended.\r\n * @example\r\n * ```ts\r\n * class MyFunction<T> extends util.ExtensibleFunction {\r\n *   constructor(f: (...args: any[]) => any) {\r\n *     let self: MyFunction<T> | undefined = undefined;\r\n *     super(f.name, function anonymous(...args: any[]) {\r\n *       // do something with self\r\n *       return f.call(self, ...args);\r\n *     });\r\n *     self = this;\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport class ExtensibleFunction extends Function {\r\n  constructor(name: string, f: any) {\r\n    Object.defineProperty(f, 'name', { value: name });\r\n    super(f);\r\n    return Object.setPrototypeOf(f, new.target.prototype);\r\n  }\r\n}\r\n","import { sort as timsort } from 'timsort';\nimport { Comparator, compareString, compareNumber, compareNumeric } from '../../sort';\n\nexport interface ISortedArrayOptions<T> {\n  data?: Iterable<T>;\n  compare?: Comparator;\n  allowDuplicates?: boolean;\n}\n\nexport class SortedArray<T> extends Array {\n  private compare: Comparator = compareString;\n  private compareFound = false;\n  private allowDuplicates = true;\n\n  constructor(options: ISortedArrayOptions<T> = {}) {\n    super();\n    Object.defineProperty(this, 'compare', { enumerable: false });\n    Object.defineProperty(this, 'compareFound', { enumerable: false });\n    Object.defineProperty(this, 'allowDuplicates', { enumerable: false });\n    if (options.compare) {\n      this.compare = options.compare;\n      this.compareFound = true;\n    }\n    if (options.data) {\n      for (const e of options.data) {\n        this.push(e);\n      }\n      if (!this.compareFound && this.length && typeof this[0] !== 'string') {\n        this.compare = compareNumeric;\n        this.compareFound = true;\n      }\n      timsort(this, this.compare);\n    }\n    if (options.allowDuplicates === false) {\n      this.allowDuplicates = false;\n      this.unique();\n    }\n  }\n\n  /**\n   * Convert to a normal Array instance\n   */\n  public toArray(): Array<T> {\n    return Array.from(this);\n  }\n\n  public add(element: T): SortedArray<T> {\n    if (!this.compareFound) {\n      if (typeof element !== 'string') {\n        this.compare = compareNumeric;\n        this.compareFound = true;\n      }\n    }\n    if (this.length === 0) {\n      this.push(element);\n      return this;\n    }\n    const [index, foundIdentical] = this.insertionIndex(element);\n    if (foundIdentical && !this.allowDuplicates) return this;\n    this.splice(index, 0, element);\n    return this;\n  }\n\n  /**\n   * Add elements to the sorted array.\n   * @param elements - The elements to add to the sorted array\n   */\n  public addMany(...elements: T[]): SortedArray<T> {\n    if (elements.length === 0) return this;\n    for (const e of elements) {\n      this.add(e);\n    }\n    return this;\n  }\n\n  /**\n   * Remove all duplicate elements in the sorted array, leaving only unique values. Equality is determined by the compare function.\n   */\n  public unique(): SortedArray<T> {\n    let len = this.length;\n    if (len <= 1) return this;\n    for (let prev, curr, i = 1; i < len; i++) {\n      prev = this[i - 1];\n      curr = this[i];\n      if (this.compare(prev, curr) === 0) {\n        this.splice(i, 1);\n        len--;\n        i--;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Returns a tuple containing the index of where to add an element to keep the array sorted and also whether an identical element was found.\n   * @param element - The element for which to find its insertion index\n   */\n  public insertionIndex(element: T): [number, boolean] {\n    if (this.length === 0) return [0, false];\n    let low = 0;\n    let high = this.length;\n    while (low < high) {\n      const mid = (low + high) >>> 1;\n      const order = this.compare(this[mid], element);\n      if (order === 0) return [mid, true];\n      if (order < 0) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return [low, false];\n  }\n\n  /**\n   * Returns a tuple containing the first index of where to add an element to keep the array sorted and also whether an identical element was found.\n   * @param element - The element for which to find its insertion index\n   */\n  public firstInsertionIndex(element: T): [number, boolean] {\n    const [index, foundIdentical] = this.insertionIndex(element);\n    if (!foundIdentical) return [index, foundIdentical];\n    let i = index - 1;\n    while (i >= 0) {\n      if (this.compare(this[i], element) !== 0) {\n        return [i + 1, foundIdentical];\n      }\n      i--;\n    }\n    return [0, foundIdentical];\n  }\n\n  /**\n   * Returns a tuple containing the last index of where to add an element to keep the array sorted and also whether an identical element was found.\n   * @param element - The element for which to find its insertion index\n   */\n  public lastInsertionIndex(element: T): [number, boolean] {\n    const [index, foundIdentical] = this.insertionIndex(element);\n    if (!foundIdentical) return [index, foundIdentical];\n    let i = index + 1;\n    while (i < this.length) {\n      if (this.compare(this[i], element) !== 0) {\n        return [i, foundIdentical];\n      }\n      i++;\n    }\n    return [this.length, foundIdentical];\n  }\n\n  /**\n   * Returns the index of the first element found that is determined equal by the compare function.\n   * @param element - The element to find\n   */\n  public indexOfCompare(element: T): number {\n    if (this.length === 0) return -1;\n    if (this.length === 1) return this.compare(this[0], element) === 0 ? 0 : -1;\n    const [index, foundIdentical] = this.insertionIndex(element);\n    return foundIdentical ? index : -1;\n  }\n\n  /**\n   * Returns the index of the first element that is determined equal by the compare function.\n   * @param element - The element to find\n   */\n  public firstIndexOfCompare(element: T): number {\n    if (this.length === 0) return -1;\n    if (this.length === 1) return this.compare(this[0], element) === 0 ? 0 : -1;\n    const [index, foundIdentical] = this.firstInsertionIndex(element);\n    return foundIdentical ? index : -1;\n  }\n\n  /**\n   * Returns the index of the last element that is determined equal by the compare function.\n   * @param element - The element to find\n   */\n  public lastIndexOfCompare(element: T): number {\n    if (this.length === 0) return -1;\n    if (this.length === 1) return this.compare(this[0], element) === 0 ? 0 : -1;\n    const [index, foundIdentical] = this.lastInsertionIndex(element);\n    return foundIdentical ? index - 1 : -1;\n  }\n\n  /**\n   * Returns all indices at which element exists. Equality is determined by the compare function.\n   * @param element - The element to find\n   */\n  public indicesOfCompare(element: T): Array<number> {\n    const index = this.indexOfCompare(element);\n    if (index === -1) return [];\n    const result: Array<number> = [];\n    if (!this.allowDuplicates) return result;\n    let i = index - 1;\n    while (i >= 0) {\n      if (this.compare(this[i], element) === 0) {\n        result.push(i);\n      } else {\n        break;\n      }\n      i--;\n    }\n    result.push(index);\n    i = index + 1;\n    while (i < this.length) {\n      if (this.compare(this[i], element) === 0) {\n        result.push(i);\n      } else {\n        break;\n      }\n      i++;\n    }\n    result.sort(compareNumber);\n    return result;\n  }\n\n  /**\n   * Returns the interestion of this and another sorted array.\n   * @param sorted - another sorted array with which to find intersections\n   */\n  public intersection(sorted: Array<T>): Array<T> {\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    // if a1 curr < a2 curr, loop a1 elems until a1 curr >= a2 curr\n    while (i1 < this.length && i2 < sorted.length) {\n      if (this.compare(this[i1], sorted[i2]) < 0) {\n        i1++;\n      } else if (this.compare(this[i1], sorted[i2]) === 0) {\n        result.push(this[i1]);\n        i1++;\n        i2++;\n      } else {\n        i2++;\n      }\n    }\n    return result;\n  }\n}\n","/**\r\n * For recording time passed since constructor was invoked and until the stop() method i called.\r\n */\r\nexport class Timer {\r\n  /**\r\n   * The initial time\r\n   */\r\n  public t0: number;\r\n\r\n  constructor() {\r\n    this.t0 = Date.now();\r\n  }\r\n\r\n  /**\r\n   * Returns the time passed since constructor was invoked in milliseconds.\r\n   */\r\n  public stop(): number {\r\n    return Date.now() - this.t0;\r\n  }\r\n}\r\n","import { arrAssignFrom, Predicate } from '../../array';\n\n/**\n * Same as Array.prototype.filter but performs operations in palce (not immutable).\n * @param input - input array\n * @param f - predicate\n */\nexport function arrFilterMutable<T>(input: Array<T>, f: Predicate): Array<T> {\n  return arrAssignFrom(input, input.filter(f));\n}\n","import { arrAssignFrom } from './arrAssignFrom';\nimport { arrFlatten } from './arrFlatten';\n\n/**\n * Flattens the passed array recursively. Mutable.\n * @param input - the array to flatten\n * @param maxDepth - the maximum recursive flattening depth.\n */\nexport function arrFlattenMutable<T>(\n  input: Array<any>,\n  maxDepth = Number.MAX_SAFE_INTEGER,\n): Array<T> {\n  return arrAssignFrom(input, arrFlatten(input, maxDepth));\n}\n","/**\n * Returns all indexes at which an element is found.\n * @param input - The array to search\n * @param element - The element to find\n */\n\nexport function arrIndicesOf<T>(input: Array<T>, element: T): Array<number> {\n  const result: Array<number> = [];\n  for (let i = 0; i < input.length; i++) {\n    if (element === input[i]) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n","import { arrSwap } from './arrSwap';\nimport { arrShallowEquals } from './arrShallowEquals';\n\n/**\n * Shuffle items in an array in-place. Guarantees that the array has changes.\n * @param input - The array to shuffle.\n */\nexport function arrShuffle<T>(input: Array<T>): Array<T> {\n  const original = input.slice();\n  let equal = true;\n  while (equal) {\n    for (let i = 0, len = input.length; i < len; i++) {\n      const newIndex = Math.floor(Math.random() * len);\n      arrSwap(input, i, newIndex);\n    }\n    equal = arrShallowEquals(input, original);\n  }\n  return input;\n}\n","import { Predicate } from '../';\n\n/**\n * Check whether a condition is true for any element of an array. The condition check is in the form of a callback.\n * @param input - The array\n * @param  predicate - A predicate callback function\n */\n\nexport function arrSome<T>(input: Array<T>, predicate: Predicate): boolean {\n  for (let i = 0, len = input.length; i < len; i++) {\n    if (predicate(input[i], i, input) === true) {\n      return true;\n    }\n  }\n  return false;\n}\n","import { compareNumeric } from '../../sort';\n\n/**\n * Uses Array.prototype.sort but sorts numbers.\n * @param input - input array\n */\nexport function arrSortNumeric(\n  input: Array<number | bigint | boolean>,\n): Array<number | bigint | boolean> {\n  return input.sort(compareNumeric);\n}\n","import { colToLetter } from './colToLetter';\n\n/**\n * Convert spreadsheet [column, row] to A1-notation.\n * @param CR - [column, row]\n * @param zeroIndexed - Whether or not column number start at one or zero.\n */\nexport function colRowToA1(CR: Array<number>, zeroIndexed = false): string {\n  if (CR.length !== 2)\n    throw new Error(`Expected CR to to be length 2. Got: ${CR.length}`);\n  if (!Number.isInteger(CR[1]))\n    throw new Error(`Expected row to be an integer. Got: ${CR[1]}`);\n  if (CR[1] < 1)\n    throw new Error(`Expected row to be greater than zero. Got: ${CR[1]}`);\n  return colToLetter(CR[0], zeroIndexed) + CR[1].toString();\n}\n","/**\n * Converts the table element's data content to a 2-dimensional array.\n * @param {HTMLElement} element - The table element\n * @param {boolean} headers - Whether to extract table column header data from <th> elements.\n * @returns {Array<Array<string>>} Data table which is an arrays of row-arrays of cell content (string).\n */\nexport function htmlTableTo2dArray(\n  element: HTMLTableElement,\n  headers = true,\n): Array<Array<string>> {\n  const result = [];\n  const htmlRows = element.querySelectorAll('tr');\n  for (let i = 0; i < htmlRows.length; i++) {\n    const htmlRow = htmlRows[i];\n    const row = [];\n    const htmlCells = htmlRow.querySelectorAll(headers ? 'th,td' : 'td');\n    for (let j = 0; j < htmlCells.length; j++) {\n      const htmlCell = htmlCells[j] as HTMLElement;\n      row.push(htmlCell.innerText.trim());\n    }\n    if (!headers) {\n      if (htmlRow.querySelectorAll('th').length) {\n        continue;\n      }\n    }\n    if (row.length) {\n      result.push(row);\n    }\n  }\n  return result;\n}\n","/**\r\n * Returns the set intersection of a provded array of Set instances.\r\n * @param sets - an array of Set instances\r\n */\r\nexport function setIntersection(sets: Array<Set<any>>): Set<any> {\r\n  const result = new Set(sets[0].values());\r\n  for (let i = 1; i < sets.length; i++) {\r\n    for (const value of result.values()) {\r\n      if (!sets[i].has(value)) {\r\n        result.delete(value);\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Returns the set union of a provded array of Set instances.\r\n * @param sets - an array of Set instances\r\n */\r\nexport function setUnion(sets: Array<Set<any>>): Set<any> {\r\n  const result = new Set(sets[0].values());\r\n  for (let i = 1; i < sets.length; i++) {\r\n    for (const value of sets[i].values()) {\r\n      result.add(value);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n"],"names":["arr2dToCSV","input","delimiter","map","row","join","arrAssignFrom","target","source","splice","length","i","arrEvery","predicate","len","arrFlatten","maxDepth","Number","MAX_SAFE_INTEGER","accum","recurse","arr","depth","Array","isArray","push","arrMapMutable","f","arrShallowEquals","input1","input2","value","arrSwap","from","to","compareNumber","a","b","compareNumeric","compareString","localeCompare","Matrix","static","array","cols","m","this","r","Error","c","matrix","iterable","fromArray","size","constructor","rows","immutable","fill","isSameInstanceAs","other","getImmutable","setImmutable","deepEquals","set","col","clone","get","has","toArray","result","slice","forEach","forEachInRow","forEachInCol","forEachInDiagonal","Math","min","Symbol","iterator","values","mapRow","mapCol","appendRow","appendCol","addBy","n","subtractBy","multiplyBy","divideBy","addRowBy","subtractRowBy","multiplyRowBy","divideRowBy","addColBy","subtractColBy","multiplyColBy","divideColBy","swapRows","row1","row2","r1","r2","swapCols","col1","col2","v1","v2","some","every","hasDimensions","isSquareMatrix","isScalarMatrix","val","isZeroMatrix","dotProduct","steps","step","isPrototype","isObject","prototype","isConstructor","setNonEnumerablePrivateProperties","object","setNonEnumerable","propertyNames","propertyName","Object","defineProperty","enumerable","keys","filter","key","charAt","hasCreatedFirstInstance","WeakSet","Base","onFirstInstance","add","assertInterfaceStaticMembers","interfaceName","requiredPropertyNames","requiredStaticProperties","found","Set","proto","iteratePrototypeChain","Function","objectOrNull","Reflect","getPrototypeOf","hasOwn","staticMember","name","assertNoAmbiguousOptions","options","optionKeyPairs","key1","key2","undefined","assertNoOptionsRequireMissingOptions","rexec","regex","str","match","exec","index","groups","assign","lastIndex","regexEscapeString","replace","alphaToColMap","Map","letterToCol","A","zeroIndexed","toUpperCase","fromMem","charCodeAt","pow","REGEX_VALID_A1","A1ToColRow","A1","matches","adjust","parseInt","colToAlphaMap","Table","csv","data","split","line","trim","json","JSON","parse","super","_data","validateOptions","handleOptions","validateData","columns","columnHeaders","_columnHeaders","rowHeaders","_rowHeaders","column","spreadsheetNotation","normalizeColRow","removeColumn","normalizeCol","removeRow","normalizeRow","indexOfColumnHeader","header","indexOf","indexOfRowHeader","unshift","toArrayDataOnly","toCSV","toJSON","extractColumnHeaders","h","extractRowHeaders","validateRowMin","validateColMin","buildEmptyTableWithDimensions","targetLength","rowLength","isInteger","ensureValidRowIndex","ensureValidColIndex","String","eu","us","numFormatEU","decimalPlaces","formatter","numberFormat","truncate","padRight","integerSeparator","decimal","numFormatUS","POW10","strIsLowerCase","toLowerCase","strIsUpperCase","regexIsNumber","regexIsWord","strCountCharOccurances","char","strRepeat","strLinesTrimRight","strLinesRemoveEmpty","trimStart","trimEnd","toIntMB","floor","getMemoryUsageFormatted","format","process","memoryUsage","processAllocationMB","rss","heapAllocationMB","heapTotal","heapUsedMB","heapUsed","extenalV8","external","normalizeFileExtension","ext","test","substring","lastIndexOf","StringStream","Readable","ended","_read","nextTick","Buffer","ExtensibleFunction","setPrototypeOf","SortedArray","compare","compareFound","allowDuplicates","e","timsort","unique","element","foundIdentical","insertionIndex","addMany","elements","prev","curr","low","high","mid","order","firstInsertionIndex","lastInsertionIndex","indexOfCompare","firstIndexOfCompare","lastIndexOfCompare","indicesOfCompare","sort","intersection","sorted","i1","i2","Timer","t0","Date","now","stop","arrFilterMutable","arrFlattenMutable","arrIndicesOf","arrShuffle","original","equal","random","arrSome","arrSortNumeric","colRowToA1","CR","colToLetter","temp","letter","fromCharCode","toString","compareArray","comparator","descending","orderMultiplier","recursiveCompare","_lenCompareParent","aIsArr","bIsArr","res","aLen","bLen","lenShortest","lenCompare","compareNumberDescending","compareNumericDescending","compareStringDescending","createFileExtensionFilter","fileExtensions","filepath","Path","extname","ensureValidWindowsPath","path","throwOrFalse","msg","assert","maxLength","extendedMaxLength","noDriveLetter","getMemoryUsage","getMemoryUsageFormattedEU","bytes","getMemoryUsageFormattedUS","getWorkingDirPath","dirs","cwd","htmlTableTo2dArray","headers","htmlRows","querySelectorAll","htmlRow","htmlCells","j","htmlCell","innerText","numApproximateLog10","x","readFileStringSync","fs","readFileSync","regexGetGroupNames","re","names","setIntersection","sets","delete","setUnion","strLinesTrimLeft","strPrettifyMinifiedCode","indent","getIndents","strReplaceAll","replaceWith","flags","RegExp","strSplitWordByCamelCase","word","isCamelCaseWordBreakIndex","lastCharIndex","lastCamelCaseBreakIndex","foundCamelCase","sub","strToWords","strWrapBetween","before","after","strWrapIn","wrap","strWrapInAngleBrackets","strWrapInBraces","strWrapInBrackets","strWrapInDoubleQuotes","strWrapInParenthesis","strWrapInSingleQuotes","streamToString","stream","chunks","_a","stream_1","__asyncValues","stream_1_1","next","_b","done","_d","chunk"],"mappings":"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"}